#!/usr/bin/env bash
#
# bin/sync-migrations
#
# Syncs your local database to match exactly the migrations present on
# the current branch. Handles the tricky case where your DB has applied
# migrations from another branch that don't exist on disk anymore.
#
# Usage:
#   bin/sync-migrations            # uses default 'python manage.py'
#   bin/sync-migrations --dry-run  # just prints what it would do
#
set -euo pipefail

# ── Configuration ──────────────────────────────────────────────────────
MANAGE="python manage.py"
APP="tab"
MIGRATIONS_DIR="mittab/apps/tab/migrations"

DRY_RUN=false
if [[ "${1:-}" == "--dry-run" ]]; then
    DRY_RUN=true
fi

# ── Warning ────────────────────────────────────────────────────────────
cat <<'EOF'

╔══════════════════════════════════════════════════════════════════════╗
║  ⚠️   WARNING: DESTRUCTIVE DATABASE OPERATION                       ║
║                                                                      ║
║  This script force-syncs your local database migrations to match     ║
║  the current branch. It may:                                         ║
║                                                                      ║
║    • REVERSE applied migrations (rolling back schema changes)        ║
║    • DROP tables / columns added by other-branch migrations          ║
║    • DELETE data that was stored in those tables / columns           ║
║    • FAKE-REMOVE ghost migration records from django_migrations      ║
║                                                                      ║
║  Only use this in a LOCAL DEVELOPMENT environment.                   ║
║  Do NOT run this against a production or shared staging database.    ║
╚══════════════════════════════════════════════════════════════════════╝

EOF

if [[ "$DRY_RUN" == true ]]; then
    echo "  (running in --dry-run mode, no changes will be made)"
    echo
fi

read -rp "Are you sure you want to continue? [y/N] " confirm
case "$confirm" in
    [yY][eE][sS]|[yY]) ;;
    *)
        echo "Aborted."
        exit 0
        ;;
esac
echo

# ── Helpers ────────────────────────────────────────────────────────────
info()  { echo -e "\033[1;34m▸\033[0m $*"; }
warn()  { echo -e "\033[1;33m▸\033[0m $*"; }
err()   { echo -e "\033[1;31m✗\033[0m $*"; }
ok()    { echo -e "\033[1;32m✓\033[0m $*"; }

run() {
    if [[ "$DRY_RUN" == true ]]; then
        echo "  [dry-run] $*"
    else
        "$@"
    fi
}

# ── Step 1: Collect on-disk migrations for the app ────────────────────
info "Scanning on-disk migrations in $MIGRATIONS_DIR/ ..."

declare -a DISK_MIGRATIONS=()
for f in "$MIGRATIONS_DIR"/[0-9]*.py; do
    [[ -e "$f" ]] || continue
    name="$(basename "$f" .py)"
    DISK_MIGRATIONS+=("$name")
done

if [[ ${#DISK_MIGRATIONS[@]} -eq 0 ]]; then
    err "No migration files found in $MIGRATIONS_DIR — something is wrong."
    exit 1
fi

# Sort them so we can find the "last" one easily
IFS=$'\n' DISK_MIGRATIONS_SORTED=($(printf '%s\n' "${DISK_MIGRATIONS[@]}" | sort)); unset IFS

LAST_ON_DISK="${DISK_MIGRATIONS_SORTED[-1]}"
info "Found ${#DISK_MIGRATIONS[@]} on-disk migrations. Latest: $LAST_ON_DISK"

# Turn the list into an associative array for O(1) lookups
declare -A DISK_SET=()
for m in "${DISK_MIGRATIONS[@]}"; do
    DISK_SET["$m"]=1
done

# ── Step 2: Collect applied migrations from the DB ─────────────────────
info "Querying applied migrations for app '$APP' from the database ..."

APPLIED_RAW="$($MANAGE showmigrations "$APP" --plan 2>/dev/null \
    | grep '^\[X\]' \
    | awk '{print $2}' \
    | sed "s/^${APP}\.//" \
    || true)"

declare -a APPLIED_MIGRATIONS=()
while IFS= read -r line; do
    [[ -n "$line" ]] && APPLIED_MIGRATIONS+=("$line")
done <<< "$APPLIED_RAW"

info "Found ${#APPLIED_MIGRATIONS[@]} applied migrations in the database."

# ── Step 3: Find ghost migrations (applied in DB but not on disk) ──────
#
# These are the dangerous ones — they came from another branch. We need
# to figure out the right way to undo them.
#
declare -a GHOST_MIGRATIONS=()
declare -a NORMAL_APPLIED=()

for m in "${APPLIED_MIGRATIONS[@]}"; do
    if [[ -z "${DISK_SET[$m]+_}" ]]; then
        GHOST_MIGRATIONS+=("$m")
    else
        NORMAL_APPLIED+=("$m")
    fi
done

# ── Step 4: Find unapplied on-disk migrations ─────────────────────────
declare -A APPLIED_SET=()
for m in "${APPLIED_MIGRATIONS[@]}"; do
    APPLIED_SET["$m"]=1
done

declare -a UNAPPLIED_MIGRATIONS=()
for m in "${DISK_MIGRATIONS_SORTED[@]}"; do
    if [[ -z "${APPLIED_SET[$m]+_}" ]]; then
        UNAPPLIED_MIGRATIONS+=("$m")
    fi
done

# ── Step 5: Report ─────────────────────────────────────────────────────
echo
echo "═══════════════════════════════════════════════════"
echo "  Migration sync plan for '$APP'"
echo "═══════════════════════════════════════════════════"
echo
echo "  On-disk migrations:     ${#DISK_MIGRATIONS[@]}"
echo "  Applied in DB:          ${#APPLIED_MIGRATIONS[@]}"
echo "  Ghost (other-branch):   ${#GHOST_MIGRATIONS[@]}"
echo "  Unapplied (this branch):${#UNAPPLIED_MIGRATIONS[@]}"
echo

if [[ ${#GHOST_MIGRATIONS[@]} -eq 0 && ${#UNAPPLIED_MIGRATIONS[@]} -eq 0 ]]; then
    ok "Database is already in sync with this branch. Nothing to do!"
    exit 0
fi

if [[ ${#GHOST_MIGRATIONS[@]} -gt 0 ]]; then
    warn "Ghost migrations to remove:"
    for m in "${GHOST_MIGRATIONS[@]}"; do
        echo "    - $m"
    done
    echo
fi

if [[ ${#UNAPPLIED_MIGRATIONS[@]} -gt 0 ]]; then
    info "Unapplied migrations to apply:"
    for m in "${UNAPPLIED_MIGRATIONS[@]}"; do
        echo "    + $m"
    done
    echo
fi

# ── Step 6: Handle ghost migrations ───────────────────────────────────
#
# Strategy:
#
# Ghost migrations sit "on top of" real migrations in the history. We
# need to reverse to a point before them, then clean up the records.
#
# 1. Find the latest NORMAL applied migration (exists on disk AND in DB).
#    This is the target state we want to migrate backwards to.
# 2. Try `migrate <app> <target>` — Django will reverse everything
#    after that target, INCLUDING the ghosts. If a ghost file is missing,
#    Django can't reverse it through the normal mechanism, so we fall
#    back to fake-removing the record from django_migrations.
# 3. Then forward-migrate to apply any new on-disk migrations.
#
if [[ ${#GHOST_MIGRATIONS[@]} -gt 0 ]]; then
    info "Handling ${#GHOST_MIGRATIONS[@]} ghost migration(s) ..."

    # Find the common ancestor: the highest-numbered migration that is
    # both on disk and applied. We roll back to this point.
    COMMON_ANCESTOR=""
    for (( i=${#DISK_MIGRATIONS_SORTED[@]}-1; i>=0; i-- )); do
        candidate="${DISK_MIGRATIONS_SORTED[$i]}"
        if [[ -n "${APPLIED_SET[$candidate]+_}" ]]; then
            COMMON_ANCESTOR="$candidate"
            break
        fi
    done

    if [[ -n "$COMMON_ANCESTOR" ]]; then
        info "Common ancestor (rollback target): $COMMON_ANCESTOR"

        # Attempt a real rollback first. This will work if all migrations
        # between current state and ancestor still have their files (even
        # if they're ghosts). If it fails, we fall back to faking.
        info "Attempting to reverse migrations back to $COMMON_ANCESTOR ..."
        if ! run $MANAGE migrate "$APP" "$COMMON_ANCESTOR" 2>/dev/null; then
            warn "Real rollback failed (missing migration files). Falling back to fake removal."

            # Fake-reverse: just delete the ghost records from django_migrations
            # so Django doesn't think they're applied.
            for ghost in "${GHOST_MIGRATIONS[@]}"; do
                warn "Fake-removing ghost migration: $ghost"
                run $MANAGE migrate "$APP" "$ghost" --fake 2>/dev/null || true

                # If the above didn't work (the file doesn't exist at all),
                # we have to directly remove the row from django_migrations.
                # We use Django's ORM via a management shell one-liner.
                if [[ "$DRY_RUN" != true ]]; then
                    $MANAGE shell -c "
from django.db import connection
with connection.cursor() as cursor:
    cursor.execute(
        \"DELETE FROM django_migrations WHERE app = %s AND name = %s\",
        ['$APP', '$ghost']
    )
    print(f'  Deleted django_migrations row: $APP / $ghost  (rows={cursor.rowcount})')
" 2>/dev/null || true
                else
                    echo "  [dry-run] DELETE FROM django_migrations WHERE app='$APP' AND name='$ghost'"
                fi
            done

            # Now we might have tables/columns left behind from the ghost
            # migrations. We can't cleanly reverse them without the files,
            # so we just warn. In dev this is usually fine — the next
            # forward migration or a fresh DB will fix it.
            warn "Ghost migration DB records removed. Orphaned tables/columns"
            warn "may remain — this is expected in dev. Run 'migrate' to"
            warn "re-apply the current branch's migrations."
        fi
    else
        # No common ancestor means no on-disk migration has ever been applied.
        # This is unusual but can happen with a totally fresh branch.
        warn "No common ancestor found. Wiping all applied migration records for '$APP'."
        for ghost in "${GHOST_MIGRATIONS[@]}"; do
            if [[ "$DRY_RUN" != true ]]; then
                $MANAGE shell -c "
from django.db import connection
with connection.cursor() as cursor:
    cursor.execute(
        \"DELETE FROM django_migrations WHERE app = %s AND name = %s\",
        ['$APP', '$ghost']
    )
    print(f'  Deleted django_migrations row: $APP / $ghost  (rows={cursor.rowcount})')
" 2>/dev/null || true
            else
                echo "  [dry-run] DELETE FROM django_migrations WHERE app='$APP' AND name='$ghost'"
            fi
        done
    fi

    echo
fi

# ── Step 7: Forward-migrate to apply this branch's migrations ─────────
info "Running forward migration to apply current branch's migrations ..."
run $MANAGE migrate "$APP"

echo
ok "Done! Database migrations are now in sync with the current branch."
echo
info "Tip: if you see leftover tables from old branches, a fresh DB is the cleanest fix:"
echo "      python manage.py flush --no-input && python manage.py migrate"
echo
